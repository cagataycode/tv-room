import * as THREE from "three";

export class ModelExporter {
  public static exportToOBJ(group: THREE.Group): string {
    let objString = "# Retro TV Model\n";
    objString += "# Generated by Three.js ModelExporter\n\n";

    let vertexIndex = 1;
    const materials: string[] = [];

    group.traverse((child) => {
      if (child instanceof THREE.Mesh) {
        const geometry = child.geometry;
        const material = child.material;

        // Add material definition
        if (material instanceof THREE.MeshLambertMaterial) {
          const materialName = `material_${materials.length}`;
          materials.push(materialName);
          objString += `newmtl ${materialName}\n`;
          objString += `Kd ${material.color.r} ${material.color.g} ${material.color.b}\n`;
          objString += `d ${material.opacity}\n\n`;
        }

        // Add vertices
        const positionAttribute = geometry.getAttribute("position");
        if (positionAttribute) {
          for (let i = 0; i < positionAttribute.count; i++) {
            const x = positionAttribute.getX(i);
            const y = positionAttribute.getY(i);
            const z = positionAttribute.getZ(i);
            objString += `v ${x} ${y} ${z}\n`;
          }
        }

        // Add faces
        const indexAttribute = geometry.getIndex();
        if (indexAttribute) {
          objString += `usemtl ${materials[materials.length - 1]}\n`;
          for (let i = 0; i < indexAttribute.count; i += 3) {
            const a = indexAttribute.getX(i) + vertexIndex;
            const b = indexAttribute.getX(i + 1) + vertexIndex;
            const c = indexAttribute.getX(i + 2) + vertexIndex;
            objString += `f ${a} ${b} ${c}\n`;
          }
        } else {
          // No index buffer, use position indices
          objString += `usemtl ${materials[materials.length - 1]}\n`;
          for (let i = 0; i < positionAttribute.count; i += 3) {
            const a = i + vertexIndex;
            const b = i + 1 + vertexIndex;
            const c = i + 2 + vertexIndex;
            objString += `f ${a} ${b} ${c}\n`;
          }
        }

        vertexIndex += positionAttribute.count;
        objString += "\n";
      }
    });

    return objString;
  }

  public static downloadOBJ(
    objString: string,
    filename: string = "retro_tv.obj"
  ): void {
    const blob = new Blob([objString], { type: "text/plain" });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }

  public static exportToGLTF(_group: THREE.Group): Promise<Blob> {
    // Note: For full GLTF export, you would need to install @gltf-transform/core
    // This is a simplified version that creates a basic GLTF structure
    return new Promise((resolve) => {
      const gltf = {
        asset: {
          version: "2.0",
          generator: "Three.js ModelExporter",
        },
        scene: 0,
        scenes: [
          {
            nodes: [0],
          },
        ],
        nodes: [
          {
            mesh: 0,
          },
        ],
        meshes: [
          {
            primitives: [
              {
                attributes: {
                  POSITION: 0,
                },
              },
            ],
          },
        ],
        accessors: [],
        bufferViews: [],
        buffers: [],
      };

      // This is a simplified implementation
      // For full GLTF support, use @gltf-transform/core library
      const blob = new Blob([JSON.stringify(gltf, null, 2)], {
        type: "application/json",
      });
      resolve(blob);
    });
  }

  public static downloadGLTF(
    gltfBlob: Blob,
    filename: string = "retro_tv.gltf"
  ): void {
    const url = URL.createObjectURL(gltfBlob);
    const link = document.createElement("a");
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }
}
